<body>
<style>
:root {
	--color1: #007cc9;
	--color2: #3c3c3c;
	--color3: #666;
	--color4: #252525;
}

:where(:not(img, select)) {
	all: unset;
	display: revert;
	box-sizing: border-box;
}

::-webkit-scrollbar {
	width: .5rem;
	height: .5rem;
}

::-webkit-scrollbar-thumb {
	background-color: var(--color3);
}

html {
	font: 13px/1.4em "Segoe WPC", "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
	background: var(--color4);
	color: #ccc;
	margin: 0;
}

body {
	display: grid;
	grid-template-columns: 25rem auto;
	grid-template-rows: auto auto 10rem auto 1fr;
}

code {
	font-family: monospace;
}

a {
	text-decoration: underline;
	cursor: pointer;
	font-weight: bold;
}

h1 {
	grid-column: 1/-1;
	display: flex;
	justify-content: space-between;
	margin: 1rem;
}

h1 .title {
	font-weight: bold;
}

#inputs {
	margin: 0 1rem 1rem;
	border: 1px dashed var(--color3);
	grid-row: span 3;
	word-break: break-all;
	height: 14rem;
	overflow: auto;
	display: flex;
	flex-direction: column;
}

#inputs:empty::after {
	content: "Drag & drop files here.";
	display: flex;
	width: 100%;
	height: 100%;
	align-items: center;
	justify-content: center;
	color: var(--color3);
}

#inputs div {
	padding: .2rem .5rem;
}

#inputs div:hover {
	background: var(--color2);
}

#templates {
	margin: 0 1rem 0 0;
	background: var(--color2);
	color: inherit;
	outline: none;
}

#arguments {
	margin: 0 1rem 1rem 0;
	background: var(--color2);
	padding: .5rem;
}

#start {
	margin: 0 1rem 1rem 0;
	background: var(--color1);
	justify-self: end;
	padding: 0.2rem 0.5rem;
	font-weight: bold;
	color: white;
}

#log {
	grid-column: 1/-1;
	white-space: pre-wrap;
	overflow: auto;
	background: #1e1e1e;
	border: 1rem solid #1e1e1e;
}

#log .row {
	font-family: monospace;
}

#log .row .time {
	color: var(--color3);
	margin-right: 1rem;
}

#log .args .message {
	color: var(--color1);
}

#log .file {
	display: inline-block;
	background: var(--color4);
	padding: 1rem 1rem .5rem 1rem;
	margin: 0 .5rem .5rem 0;
}

#log .file :is(img, video) {
	height: 20rem;
}

#log .file a {
	display: block;
}

</style>
<h1><span class="title">FFmpeg Online</span> <span>powered by <a href="https://wide.video">wide.video</a> | Free Online Video Editor</span></h1>
<div id="inputs"></div>
<select id="templates"></select>
<textarea id="arguments"></textarea>
<button id="start">Start</button>
<div id="log"></div>

<script id="worker" type="javascript/worker">

// workaround for safari
if(!("Worker" in self)) {
	class Worker extends EventTarget {
		static id = 0;
		static subworkers = new Map();
		constructor(url) {
			super();
			this.id = Worker.id++;
			self.postMessage({kind:"subworker", id:this.id, cmd:"create", url});
			Worker.subworkers.set(this.id, this);
		}
		
		postMessage(data) {
			self.postMessage({kind:"subworker", id:this.id, cmd:"postMessage", data});
		}
		
		terminate() {
			self.postMessage({kind:"subworker", id:this.id, cmd:"terminate"});
			Worker.subworkers.delete(this.id);
		}
	}
	self.Worker = Worker;
}

self.addEventListener("message", async (event) => {
	const data = event.data;
	switch(data.kind) {
		case "subworker":
			if(data.cmd === "event")
				Worker.subworkers.get(data.id).onmessage(new MessageEvent(data.type, {data:data.data}));
			break;
		case "execute":
			const {args, inputs, wasmUrl, ffmpegUrl, ffmpegWorkerUrl} = data;
			importScripts(ffmpegUrl);
			const module = await createFFmpeg({
				stderr:(buffer, offset, length) => {
					if(!length) return;
					const message = buffer.slice(offset, offset + length).buffer;
					self.postMessage({kind:"stderr", message}, {transfer:[message]});
				},
				stdout:(buffer, offset, length) => {
					if(!length) return;
					const message = buffer.slice(offset, offset + length).buffer;
					self.postMessage({kind:"stdout", message}, {transfer:[message]});
				},
				locateFile:url => {
					if(url.endsWith(".wasm")) return wasmUrl;
					if(url.endsWith(".worker.js")) return ffmpegWorkerUrl;
					return url;},
				mainScriptUrlOrBlob:ffmpegUrl});
		
			const FS = module.FS;
			FS.mkdir("input");
			FS.mount(module.WORKERFS, {files:inputs}, "input");
			const dirContent = FS.readdir("/");
		
			module.onExit = () => {
				const files = [];
				for(const filename of FS.readdir("/"))
					if(!dirContent.includes(filename)) {
						const content = FS.readFile(filename);
						let options = undefined;
						if(filename.endsWith(".mp4")) options = {type:"video/mp4"};
						files.push(new File([content.buffer], filename, options));
					}
				self.postMessage({kind:"onExit", files});
			}
			
			module.callMain(args);
			break;
	}
});
</script>
<script>
(() => {

const inputsElement = document.getElementById("inputs");
const templatesSelect = document.getElementById("templates");
const argumentsElement = document.getElementById("arguments");
const startButton = document.getElementById("start");
const logElement = document.getElementById("log");

const simd = WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5,
	1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));

const create = (type, content, attributes) => {
	const result = document.createElement(type);
	if(Array.isArray(content))
		result.append(...content);
	else if(content !== undefined)
		result.append(content);
	if(attributes !== undefined)
		for (const [key, value] of Object.entries(attributes))
			result[key] = value;
	return result;
}

const log = content => {
	const isBottom = logElement.scrollTop >= (logElement.scrollHeight - logElement.clientHeight - 5);
	logElement.append(content);
	if(isBottom)
		logElement.scrollTop = logElement.scrollHeight;
}


const getExtension = filename => {
	const index = filename.lastIndexOf(".");
	if(index === -1)
		return;
	const extension = filename.substring(index + 1, filename.length);
	return extension.length ? extension.toLocaleLowerCase() : undefined;
}


const readLines = key => {
	const result = [];
	while(true) {
		const buffer = buffers[key];
		const indexN = buffer.indexOf("\n");
		const indexR = buffer.indexOf("\r");
		if(indexN === -1 && indexR === -1)
			break;

		const index = (indexN === -1 || ((indexR !== -1 && indexR < indexN))) ? indexR : indexN;
		result.push(buffer.substring(0, index));
		buffers[key] = buffer.substring(index + 1);
	}
	return result;
}

const formatSize = value => {
	const mb = value / 1024 / 1024;
	return mb > 100 ? (mb / 1024).toFixed(1) + "G" : mb.toFixed(1) + "M";
}

const decoder = new TextDecoder("utf8");
const buffers = {};

if(typeof SharedArrayBuffer === "undefined") {
	return log(create("p", undefined, {innerHTML:
		"SharedArrayBuffer is not available. Run <code>chrome --enable-features=SharedArrayBuffer</code> or follow <a href='https://web.dev/cross-origin-isolation-guide/'>A guide to enable cross-origin isolation</a>."}));
}

const inputs = [];

inputsElement.ondrop = event => {
	event.preventDefault();
	const files = event.dataTransfer.files;
	[...files].forEach(file => inputs.push(file));

	inputsElement.innerHTML = "";
	for(file of inputs) {
		const path = `input/${file.name}`;
		const div = create("div", path);
		div.ondblclick = () => {
			navigator.clipboard.writeText(path);

			const range = document.createRange();
			range.selectNodeContents(div);
			const selection = window.getSelection(); 
			selection.removeAllRanges(); 
			selection.addRange(range); 
		}
		inputsElement.append(div);
	}
}

inputsElement.ondragover = event => event.preventDefault();

templatesSelect.append(create("option", "SMPTE Color Bars", {value:`-filter_complex smptehdbars=size=320x240:rate=30000/1001;sine=frequency=440:sample_rate=48000:beep_factor=2
-c:v libopenh264 -pix_fmt:v yuv420p -profile:v high
-c:a aac -ac 2
-t 5 out.mp4 -movflags +faststart`}));

templatesSelect.append(create("option", "Flip Horizontally", {value:`-i input/myinput -vf hflip 
-c:a copy -c:v libopenh264 out.mp4`}));

templatesSelect.append(create("option", "Extract Frames", {value:`-i input/myinput frame%03d.jpg`}));

templatesSelect.onchange = () => argumentsElement.value = templatesSelect.value;

argumentsElement.value = templatesSelect.value;


startButton.onclick = async () => {
	const t0 = performance.now();
	const logRow = (message, className) => log(create("p", [
		create("span", (performance.now() - t0).toFixed(0).padStart(5, "0"), {className:"time"}),
		create("span", message, {className:"message"})], {className:"row " + (className ?? "")}));

	buffers.stdout = "";
	buffers.stderr = "";

	const wasmUrl = new URL(simd ? "ffmpeg-simd.wasm" : "ffmpeg.wasm", document.location).href;
	const ffmpegUrl = new URL(simd ? "ffmpeg-simd.js" : "ffmpeg.js", document.location).href;
	const ffmpegWorkerUrl = new URL(simd ? "ffmpeg-simd.worker.js" : "ffmpeg.worker.js", document.location).href;

	const workerBlob = new Blob([document.querySelector('#worker').textContent], {type:"text/javascript"});
	const worker = new Worker(URL.createObjectURL(workerBlob));
	const subworkers = new Map();

	const args = argumentsElement.value.trim().split(/\s+/g);

	worker.onmessage = event => {
		const data = event.data;
		
		// workaround for safari
		switch(data.kind) {
			case "subworker":
				const {cmd, id, url} = data;
				switch(cmd) {
					case "create":
						const subworker = new Worker(url);
						subworker.onmessage = event =>
							worker.postMessage({kind:"subworker", cmd:"event", id, type:event.type, data:event.data});
						subworkers.set(id, subworker);
						break;
					case "postMessage":
						subworkers.get(id).postMessage(data.data);
						break;
					case "terminate":
						subworkers.get(id).terminate();
						subworkers.delete(id);
					
				}
				break;
			case "stderr":
			case "stdout":
				buffers[data.kind] += decoder.decode(data.message);
				for(const line of readLines(data.kind))
					logRow(line, data.kind);
				break;
			case "onExit":
				for(const file of data.files) {
					const url = URL.createObjectURL(file);
					const extension = getExtension(file.name);
					const media = ["gif", "jpg", "jpeg", "png", "webp"].includes(extension)
						? create("img", undefined, {src:url})
						: create("video", undefined, {controls:true, src:url});
					log(create("div", [ media,
						create("a", `${file.name} (${formatSize(file.size)})`, {download:file.name, href:url})], {className:"file"}));
				}
				setTimeout(() => worker.terminate(), 100);
				logRow("Finished")
				break;
		}
	}
	
	logRow(`ffmpeg ${args.join(" ")}`, "args");
	worker.postMessage({kind:"execute", args, inputs, wasmUrl, ffmpegUrl, ffmpegWorkerUrl});
}

})()
</script>
</body>